### 为什么 0.1 + 0.2 != 0.3
JS采用的是`IEEE 754`双精度版本（64位），并且只要采用`IEEE 754`的语言都有该问题。`IEEE 754`是20世纪80年代以来最广泛使用的浮点数运算标准。
计算机其实是无法对十进制进行运算的，都要按照`IEEE 754`(双精度格式)的规范转为二进制后在进行运算。因此每个浮点数转为二进制占64位，第一位是符号位(用来表示一个数是正数还是负数)，11位用于指数(允许指数最大到1024),剩下的52位代表的尾数。
- 0.1和0.2转换成二进制后无限循环,但是由于`IEEE 754`的尾数位数限制，需要将后面多余的截掉，导致精度有所损失
```
0.1 -> 0.00011001100110011...
0.2 -> 0.00110011001100110...
```
- 对阶运算的时候，由于指数位数不同，运算时需要对阶运算，这部分也可能产生精度损失。
- 解决办法： 
```
parseFloat((0.1 + 0.2).toFixed(10))
```